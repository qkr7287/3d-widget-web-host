# 테스트/분석용 정리 (크롬 네트워크·캐시)

## 첫 진입 시 오래 걸리다가 점점 줄어드는 현상 (코드상 아무것도 안 했는데 왜?)

**브라우저의 HTTP 캐시** 때문에 발생합니다.  
첫 로드 시 네트워크로 받은 리소스(JS, CSS, GLB, 이미지, 모듈 등)를 브라우저가 **메모리 캐시 / 디스크 캐시**에 저장해 두었다가, 이후 같은 URL로 요청할 때 다시 받지 않고 저장된 걸 불러와서 **점점 빨라집니다**.  
(IndexedDB·Service Worker 같은 별도 구현 없이도 브라우저 기본 동작입니다.)

---

## 메모리 캐시 vs 디스크 캐시

| 구분 | 메모리 캐시 (memory cache) | 디스크 캐시 (disk cache) |
|------|----------------------------|---------------------------|
| **저장 위치** | RAM(브라우저 프로세스 메모리) | SSD/HDD의 브라우저 캐시 폴더 |
| **속도** | 가장 빠름 | 네트워크보다 훨씬 빠르지만, 메모리보다는 느릴 수 있음 |
| **지속성** | 탭/브라우저를 닫으면 보통 사라짐(휘발성) | 브라우저 재시작 후에도 남을 수 있음 (용량/정책에 따라 정리됨) |
| **특징** | 같은 페이지·탭에서 같은 리소스를 다시 쓸 때 “즉시 재사용”에 유리 | 재방문(다음날 다시 들어오는 경우 등) 가속에 유리 |

DevTools Network 탭에서 **Size / Transferred**에 `(memory cache)` 또는 `(disk cache)`로 표시됩니다.

---

## 캐시되는 리소스 vs 안 되는 리소스

### “캐시 됐는지” 어떻게 아나?

- **캐시로 표시되는 경우**: Size/Transferred에 `(memory cache)` 또는 `(disk cache)`가 보이거나, **Status 304 Not Modified**인 경우.
- **캐시 문구는 없는데 사이즈가 줄어든 경우**:  
  초기 로드보다 **Transferred(전송량)**가 많이 줄었으면, 304 재검증이나 다른 방식으로 **캐시 재사용**이 된 것입니다.  
  이때 보이는 숫자는 “리소스 자체 크기”를 나타내는 경우가 많고, 실제로는 **캐싱·재사용 때문에 전송량이 거의 없어서** cache 문구 없이 작은 값으로 보일 수 있습니다.

→ **“디스크/메모리 캐시”로만 표시되는 것만 캐싱된 게 아니라, 첫 로드보다 전송량이 확 줄어든 요청들도 전부 캐싱 또는 재사용된 결과로 보면 됩니다.**

---

### 캐시 **안** 되는 것들

- **서버가 저장 금지한 경우**  
  - 응답 헤더에 `Cache-Control: no-store` 등이 있으면 브라우저가 저장하지 않습니다.
- **URL이 매번 달라지는 경우**  
  - 캐시 키가 URL 단위라서, `?t=123`처럼 매번 바뀌는 쿼리가 붙거나, 버전마다 URL이 바뀌면 캐시 미스가 납니다.

---

### 캐시 **되는** 것들

- **(HTTP 캐시 기준)**  
  - **GET** 요청이고,  
  - 서버가 `Cache-Control: max-age=...`처럼 “이만큼은 그대로 써도 된다”를 주거나,  
  - `ETag` / `Last-Modified`로 “바뀌었는지 확인 가능”하게 해주면  
  → 브라우저가 (memory cache)/(disk cache) 또는 **304 재검증**으로 재사용합니다.

- **(ESM 모듈 캐시)**  
  - 같은 페이지에서 `import(같은 URL)`을 다시 하면, 브라우저가 **모듈 로더 레벨**에서 이미 로드한 모듈을 재사용합니다. (HTTP 캐시와 별개)  
  - 예: Host에서 `import(".../embed.ts")` 또는 `import(".../embed.js")`를 연속으로 호출할 때, 두 번째부터는 네트워크를 거의 타지 않고 빨라질 수 있습니다.

- **(에셋: 3D 모델, 이미지 등)**  
  - `SceneLoader.ImportMeshAsync(..., modelUrl, ...)`로 받는 GLB, 이미지 등은 **HTTP 요청**으로 내려받습니다.  
  - 서버가 `max-age`를 주거나 `ETag`/`Last-Modified`를 주면 **(memory/disk cache)** 또는 **304 재검증**으로 빨라질 수 있습니다.  
  - **dev 서버**는 보통 강한 캐시를 주지 않아서, “항상 304로 확인”하거나 캐시 적중률이 들쭉날쭉할 수 있습니다.

---

## max-age / ETag / Last-Modified는 “어떻게 거냐?”

이 값들은 **프론트 코드가 아니라, 해당 리소스를 내려주는 서버·CDN이 HTTP 응답 헤더로 설정**합니다.

- **`Cache-Control: max-age=31536000`**  
  - 서버/CDN 설정(nginx `add_header`, S3 메타데이터, CloudFront 등)에서 “이 경로/파일에는 이 헤더를 붙여라”고 지정합니다.
- **`ETag` / `Last-Modified`**  
  - 서버/CDN이 응답할 때 자동으로 붙이거나, 설정으로 붙입니다.  
  - 브라우저는 다음 요청에 `If-None-Match`, `If-Modified-Since`를 보내고, 서버가 “안 바뀜”이면 **304**를 돌려줍니다.

즉, **GLB·이미지·JS 등을 서빙하는 쪽(3d-widget 쪽 정적 서버, CDN, S3 등)**에서 헤더를 어떻게 줄지 정하는 것이고, 프론트에서는 “요청만” 합니다.
